/*
*	자바스크립트 이벤트에 대한 소개
*		- 어떤 자바스크립트 코드라도 그 핵심부를 살펴보면,
*			바로 이벤트가 모든 것을 한데 묶는 접착제 같음을 깨닫게 될 것이다.
*		(1) 비동기식 이벤트 vs. 스레드
*			- 자바스크립트 이벤트 시스템은 조금 독특하다. 스레드를 사용하지 않으면서 완벽히 비동기식으로 동작한다.
*			- 이는 곧 애플리케이션의 모든 코드가, 사용자의 클릭이나 페이지 로딩 등에 대해서도 반응할 수 있음을 뜻한다.
*			- 스레드 프로그램과 비동기식 프로그램의 설계에는 근본적인 차이가 있다. 바로 어떤 사건이 발생하기를 기다리는 방식의 차이이다.
*			- 스레드 프로그램의 경우, 특정 조건이 맞는지 계속해서 확인하고 또 확인해야 한다.
*			- 비동기식 프로그램에서는 그저 이벤트 처리기를 콜백 함수로 등록해놓고, 이벤트가 발생하면 언제라도 그 처리기가 콜백 함수를 바로 실행함으로서 이벤트의 발생을 알려준다.
*		(2) 자바스크립트 스레드
*			- 자바스크립트에는 스레드가 존재하지 않는다.
*			- 스레드에 가장 근접한 것이라면 setTimeout() 콜백을 사용하는 방법이겠지만, 완전하지는 않다.
*		(3) 비동기식 콜백
*			- 어떤 DOM엘리먼트가 있고, 특정 타입의 이벤트가 이 엘리먼트에 대해 언제라도 호출될 수 있다면, 이를 처리하기 위해 호출할 함수가 필요함
*			- 원하는 시점에 실행될 코드에 대한 참조를 제공함
*			- 나머지 작업은 브라우저가 대신 해줌
*			- 이벤트 처리기에 콜백을 등록해둠
*			- 이벤트가 일어나는 순서가 변할 수 있으며, 이벤트의 타입에 따라 또는 그 이벤트가 일어나는 DOM 엘리먼트에 따라 다른 방식으로 처리될 수 있음

*/
/*
*	스레드를 흉내 내는 가상의 자바스크립트 코드
*		- 이 코드는 페이지가 완전히 로딩되기를 기다리는 가상의 코드다.
*		- window.loaded() 가 true 를 반환하는지 아닌지를 계속 확인하는 루프
*		- 자바스크립트의 모든 루프는 블로킹 방식이기 때문에 루프가 끝날 때 까지는 다른 어떤 것도 발생할 수 없다.
*		- 실제로 while 루프가 계속 실행되는 동안에는 애플리케이션의 정상적인 흐름이 막히기 때문에 절대로 true 값에 도달할 수 없다
*/
// 페이지가 로딩되기를 기다리며 계속하여 확인함
// while(!window.loaded()) {
	
//}
// 이제 페이지가 로딩되었으니 무언가 일을 시작한다.
// document.getElementById("body").style.border = "1px solid #000";

/*
*	자바스크립트의 비동기식 콜백
*		- 이벤트 처리기와 콜백을 사용하는 예
*		- 지금 즉시 실행되는 코드는 단지 이벤트 처리기(호출한 함수) 를 이벤트 리스너(onload 프로퍼티) 에 연결하는 부분임
*		- 페이지가 완전히 로딩되면 브라우저가 window.load에 연결된 함수를 호출하고 실행함
*/
// 페이지가 로딩될 때마다 호출할 함수를 등록한다.
window.onload = loaded;  // loaded() 는 함수 실행 결과가 등록됨

// 페이지가 로딩될 때마다 호출할 함수
function loaded() {
	// 이제 페이지가 로딩되었으니 필요한 작업을 시작한다.
	document.getElementsByTagName("body")[0].style.border = "1px solid #000";
//	document.getElementById("body").style.border = "1px solid #000";
}
/*
*	이벤트 단계
*		- 자바스크립트 이벤트는 "캡쳐(capturing)" 와 "버블(bubbling)" 이라는 두 단계에 걸쳐 실행된다.
*		- 즉 어떤 엘리먼트에서 이벤트가 발생하면 이 이벤트를 처리할 권한을 가지는 엘리먼트나 이 이벤트를 처리하는 순서가 경우에 따라 바뀔 수 있다.
*		(1) 캡쳐 단계
*			- 이벤트가 발생한 요소까지 document 에서부터 이벤트 처리기가 구동된다
*		(2) 버블 단계
*			- 요소 트리를 역순으로 거슬러 올라가면서 이벤트 처리기가 구동된다.
*/
/* 마우스 호버(hover) 효과를 내는 탭(tab) 탐색 시나리오
*	-모든 li 엘리먼트를 찾아서 이벤트 처리기를 붙인다.
*	- li 위에 마우스를 올릴 때마다 실제로는 서로 다른 두 개의 엘리먼트를 전환시키고 있다.
*		li 엘리먼트는 a엘리먼트를 포함하고 있으므로 마우스를 올릴 때는 단지 li 만이 아니라, a 엘리먼트 위에도 올리는 셈이다.
*/
var li = document.getElementsByTagName("li");
for (var i=0; i < li.length; i++) {
	// li 엘리먼트에 mouseover 처리기를 붙인다.
	// 이 처리기는 li 의 배경색을 파란색으로 바꾼다.
	li[i].onmouseover = function() {
		this.style.backgroundColor = "blue";
	};

	// li 엘리먼트에 mouseout 처리기를 붙인다
	// 이 처리기는 li 의 배경색을 원래의 흰색으로 되돌린다.
	li[i].onmouseout = function() {
		this.style.backgroundColor = "white";
	};
}
/*
*	이벤트가 호출되는 정확한 과정
*		(1) li mouseover : li 엘리먼트 위로 마우스를 움직인다.
*		(2) li mouseout :  li 로부터 그 안에 있는 a 로 마우스를 움직인다.
*		(3) a mouseover : 이제 a 엘리먼트 위에 마우스가 놓여있다.
*		(4) li mouseover : a mouseover 이벤트가 솟아올라(bubbles up) li mouseover 를 발생시킨다.
*
*		- 위 단계에서는 이벤트 캡쳐 단계가 무시되어 있음
* 		-  이벤트 리스너를 연결하는 데 오래된, 전통적인 방법, 즉 어떤 엘리먼트의 onevent 의 프로퍼티를 설정함으로서 이벤트를 연결하는 방법은
*			이벤트의 버블 단계만을 지원할 뿐, 캡쳐 단계는 지원하지 않는다.
*
*		- li 엘리먼트에서는 mouseout 이 일어나고 a 에서 li 로 mouseover 이벤트가 솟아오르는 과정
*		(1) mouseout 이벤트가 일어나는 이유는, 브라우저의 관점에서는 부모 엘리먼트인 li의 영역을 떠나, 또 다른 엘리먼트에 진입했다고 간주하기 때문
*			- 어떤 엘리먼트이든 그 아래에 위치한 다른 엘리먼트보다 그 위에 있는 엘리먼트가 먼저 마우스 포커스를 받는다.
*		(2) a mouseover 이벤트가 그 부모인 li 엘리먼트로 솟아오른 덕분에 코드를 절약할 수 있다.
*			- a 엘리먼트에는 어떤 이벤트 리스너도 연결하지 않았기 때문에 이벤트는 그저 DOM 트리를 따라 올라가면서 이벤트에 귀기울이고 있는 다른 엘리먼트를 찾는다.
*			- 이러한 버블 단계에서 제일 먼저 만나는 엘리먼트가 바로 li 엘리먼트, 즉 mouseover 이벤트가 들어오기를 기다리고 있는 엘리먼트임
*			- 만일, a 엘리먼트의 mouseover 엘리먼트에 이벤트 리스너를 연결해 두었다면, 이벤트의 버블과정을 멈출 수 있는 방법을 구현해야 함
*/

/*
*	이벤트 객체
*		- 이벤트 처리기의 기본적인 기능 중 하나는 바로 이벤트 객체에 접근할 수 있게 해줌
*		- 이벤트 객체는 현재 이벤트에 대한 상황정보들이 담겨 있는 자원임
*		- 예를 들어, 키보드 누름을 다루고자 할 때 이벤트 객체의 keyCode 프로퍼티에 접근함으로서 방금 눌린 특정 키를 알아낼 수 있음
*		- 이벤트 객체에 대한 구현은 IE 와 W3C 명세가 다름
*		- IE : 단 하나의 전역 이벤트 객체만 존재한다 (이 객체는 전역 변수 프로퍼티인 window.event 에서 찾을 수 있음)
*		- 그 외 브라우저 : 이벤트 처리기에서 이벤트 객체를 담고 있는 전달인자 하나를 받음
*		
*		- 이벤트 객체에서는 수많은 어트리뷰트와 함수가 존재한다.
*		- 그 명칭이나 작동 방식은 브라우저에 따라 다르다.
*/
// DOM 이벤트를 사용하여 기존 기능을 덮어쓰기
// 이벤트 객체를 범용적으로 사용하는 예
// 페이지의 첫째 textarea 를 찾고, keypress 리스너를 연결한다.
// textarea 안에서 Enter 키를 치면 일반적으로 새로운 줄바꿈이 생기는데, 이 기본 기능을 막음
document.getElementsByTagName("textarea")[0].onkeypress = function(e) {
	// 만일 이벤트 객체가 존재하지 않는다면 전역의 이벤트 객체를 선택한다.(IE)
	e = e || window.event;

	console.log(e);
	// Enter 키가 눌렸을 때 false 를 반환한다.(아무일도 하지 않는다.)
	console.log(e.keyCode);
	return e.keyCode !== 13;
}

/*
*	this 키워드
*		- this 키워드는 함수의 유효범위 내에서 현재 객체에 접근하기 위한 수단으로 쓰인다.
*		- 최신 브라우저에서는 this 키워드를 통하여 모든 이벤트 처리기에 모종의 상황정보를 전달한다.
*		- 예를 들어, 클릭을 다루는 일반 함수를 생성하는데 this 키워드 만을 사용함으로서 어떤 엘리먼트가 현재 영향 받고 있는지 알아 낸다.
*		- this 키워드는 편리함을 사용할 뿐이지, 그 이상도 이하도 아니다. 
*			this 키워드를 적절히 사용하면 자바스크립트 코드를 훨씬 더 간단하게 작성할 수 있다.
*/
// 페이지 내의 모든 클릭된 li 엘리먼트에 대해 배경색과 전경색을 변경한다.
// 모든 li 엘리먼트를 찾고 각각에 click 처리기를 연결한다.

var li2 = document.getElementsByTagName("li");

for(var i=0; i < li2.length; i++) {
	li2[i].onclick = handleClick;
}

// click 처리기 - 호출되면 지정된 엘리먼트의 배경색과 전경색을 변경한다.
function handleClick() {
	this.style.backgroundColor = "blue";
	this.style.color = "white";
}




















